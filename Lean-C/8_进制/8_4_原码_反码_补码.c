// 原码、反码、补码
#include <stdio.h>
#include <limits.h>

//int main(int argc, const char *argv[]) {
int main_8_4(int argc, const char *argv[]) {
//    printf("%d\n",INT_MIN);
//    printf("%d\n",INT_MAX);
    
    printf("%d\n",-0b1010);
    return 0;
}
/**
 原码、反码、补码
 
 1、无论任何数据在内存中存储的时候，都是二进制的形式。
     原码、反码、补码都是二进制，是二进制的不同的表现形式。
     
     数据是以补码的二进制存储的。
 
 2、1个in类型的变量，在内存中占据4个字节，等于32个位。
 
     00000000       00000000        00000000        00000000
     
     在不考虑正负的情况下，1个int类型的变量可以表示 2^32种可能。
     
     为了表示正负性，使用最高位来表示这个数的正负性。
     如果最高位是0，那么表示这个数是1个正数。
     如果最高位是1，那么表示这个数是1个负数。
     所以，来表示的数据只有32位，所以，1个int类型的变量。
     最小值：-2^31 = -2147483648,
     最大值 =  2^31-1 （因为有0）= 2147483647
 
 3、原码
 最高位表示符号位。剩下的位数，是这个数的绝对值的二进制。
 10的原码：  00000000       00000000        00000000        00001010
 -10 的原码：10000000       00000000        00000000        00001010
 
 绝对值：正数的绝对值是它自己，负数的绝对值去掉负号。
 
 4、反码
 正数的反码是它自己。
 负数的反码，是在其原码的基础上，符号位不变，其他位取反。
 
 10的反码： 00000000       00000000        00000000        00001010
 
 -10:
 -10的反码： 11111111       11111111        11111111        11110101
 
 5、补码
 正数的补码，是其原码
 负数的补码，是在其反码的基础上加1
 
 10的补码： 00000000       00000000        00000000        00001010
 
 -10:
 -10 的原码：10000000       00000000        00000000        00001010
 -10的反码： 11111111       11111111        11111111        11110101
 -10的补码： 11111111       11111111        11111111        11110110
 
 5、任何数据都是以其二进制的补码形式存储在内存中的。
 
 6、为什么数据要以补码的形式来存储？
 因为计算机中只有加法没有减法，为了更加低成本的计算出结果，所以用补码来存储数据。
 
3 + 2;
3 - 2 ; // 计算机理解的 3 +(-2)
 
 使用原码计算：
 3的原码 ：   00000000       00000000        00000000        00000011
 -2 的原码：  10000000       00000000        00000000        00000010
 加一下：       10000000       00000000        00000000        00000101
 => -5
 结果明显不对。
 
 使用反码计算：
 3的补码 ：   00000000       00000000        00000000        00000011
 -2 的反码：  11111111      11111111        11111111         11111101
 加一下：    1 00000000       00000000        00000000        00000000
 超过的1，就丢弃
 => 0
 
 使用补码计算：
 3的补码 ：   00000000       00000000        00000000        00000011
 -2 的补码：  11111111      11111111        11111111         11111110
 加一下：   1  00000000      00000000        00000000         00000001
 超过的1，就丢弃
 =>1
 
 因为使用补码来做运算，效率是最高的。
  */
